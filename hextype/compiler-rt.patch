diff --git a/cmake/config-ix.cmake b/cmake/config-ix.cmake
index 0a9e9da..ee65057 100644
--- a/cmake/config-ix.cmake
+++ b/cmake/config-ix.cmake
@@ -602,3 +602,9 @@ if (COMPILER_RT_HAS_SANITIZER_COMMON AND CFI_SUPPORTED_ARCH AND
 else()
   set(COMPILER_RT_HAS_CFI FALSE)
 endif()
+
+if (COMPILER_RT_HAS_SANITIZER_COMMON AND OS_NAME MATCHES "Linux")
+  set(COMPILER_RT_HAS_HEXTYPE TRUE)
+else()
+  set(COMPILER_RT_HAS_HEXTYPE FALSE)
+endif()
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index 718b128..ae939d4 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -48,4 +48,7 @@ if(COMPILER_RT_BUILD_SANITIZERS)
   if(COMPILER_RT_HAS_CFI)
     add_subdirectory(cfi)
   endif()
+
+  add_subdirectory(hextype)
+
 endif()
diff --git a/lib/hextype/CMakeLists.txt b/lib/hextype/CMakeLists.txt
new file mode 100644
index 0000000..c7e224f
--- /dev/null
+++ b/lib/hextype/CMakeLists.txt
@@ -0,0 +1,22 @@
+set(HEXTYPE_SOURCES
+  hextype.cc
+  hextype_rbtree.cc
+  hextype_report.cc
+  )
+
+include_directories(..)
+
+set(HEXTYPE_CFLAGS ${SANITIZER_COMMON_CFLAGS})
+
+add_custom_target(hextype)
+
+add_compiler_rt_runtime(clang_rt.hextype
+        STATIC
+        ARCHS x86_64
+        SOURCES ${HEXTYPE_SOURCES}
+        CFLAGS ${HEXTYPE_CFLAGS}
+        PARENT_TARGET hextype)
+
+add_sanitizer_rt_symbols(clang_rt.hextype)
+
+add_dependencies(compiler-rt hextype)
diff --git a/lib/hextype/hextype.cc b/lib/hextype/hextype.cc
new file mode 100644
index 0000000..40bfd6c
--- /dev/null
+++ b/lib/hextype/hextype.cc
@@ -0,0 +1,656 @@
+//===-- hextype.cc -- runtime support for HexType  ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===-------------------------------------------------------------------===//
+
+#include "hextype.h"
+#include <string.h>
+
+__attribute__((always_inline))
+  inline ObjTypeMapEntry *findObjInfo(uptr* SrcAddr) {
+    uint32_t MapIndex = getHash((uptr)SrcAddr);
+    if (ObjTypeMap[MapIndex].ObjAddr == SrcAddr) {
+#ifdef HEX_LOG
+      IncVal(numLookHit, 1);
+#endif
+      return &ObjTypeMap[MapIndex];
+    }
+
+    if (ObjTypeMap[MapIndex].HexTree != nullptr &&
+        ObjTypeMap[MapIndex].HexTree->root != nullptr) {
+      ObjTypeMapEntry *FindValue =
+        (ObjTypeMapEntry *)rbtree_lookup(ObjTypeMap[MapIndex].HexTree, SrcAddr);
+#ifdef HEX_LOG
+      if (FindValue != nullptr)
+        IncVal(numLookMiss, 1);
+      else
+        IncVal(numLookFail, 1);
+#endif
+      return FindValue;
+    }
+#ifdef HEX_LOG
+    IncVal(numLookFail, 1);
+#endif
+    return nullptr;
+  }
+
+__attribute__((always_inline))
+  inline static void* verifyTypeCasting(uptr* const SrcAddr,
+                                 uptr* const DstAddr,
+                                 const uint64_t DstTypeHashValue) {
+    if(SrcAddr == NULL) return nullptr;
+#ifdef HEX_LOG
+    IncVal(numCasting, 1);
+#endif
+    ObjTypeMapEntry *FindValue = findObjInfo(SrcAddr);
+    if (!FindValue)
+      return DstAddr;
+#ifdef HEX_LOG
+    IncVal(numVerifiedCasting, 1);
+#endif
+    if (DstAddr != SrcAddr) {
+      int OffsetTmp = FindValue->Offset;
+      if (OffsetTmp == -1)
+        OffsetTmp = 0;
+      long offset = ((char *)DstAddr - ((char *)SrcAddr - OffsetTmp));
+
+      FindValue = findObjInfo(DstAddr);
+      if (offset < 0) {
+        if (FindValue) {
+          uint64_t SrcTypeHashValue = FindValue->TypeHashValue;
+          if (SrcTypeHashValue == DstTypeHashValue) {
+#ifdef HEX_LOG
+            IncVal(numCastSame, 1);
+#endif
+            return DstAddr;
+          }
+        }
+#ifdef HEX_LOG
+        IncVal(numCastBadCast, 1);
+        IncVal(numCastBadCastMinus, 1);
+#endif
+#if defined(PRINT_BAD_CASTING) || defined(PRINT_BAD_CASTING_FILE)
+        IncVal(numBadCastType1, 1);
+        printTypeConfusion(1, 0, DstTypeHashValue);
+#endif
+        return nullptr;
+      }
+      if (!FindValue) {
+#ifdef HEX_LOG
+        IncVal(numCastBadCast, 1);
+        IncVal(numCastBadCastMinus, 1);
+#endif
+#if defined(PRINT_BAD_CASTING) || defined(PRINT_BAD_CASTING_FILE)
+        IncVal(numBadCastType2, 1);
+        printTypeConfusion(2, 0, DstTypeHashValue);
+#endif
+        return nullptr;
+      }
+    }
+
+    uint64_t SrcTypeHashValue = FindValue->TypeHashValue;
+    uint64_t CacheIndex;
+    CacheIndex = (SrcTypeHashValue & 0xfff);
+    CacheIndex <<= 12;
+    CacheIndex |= (DstTypeHashValue & 0xfff);
+
+    if (SrcTypeHashValue == DstTypeHashValue) {
+#ifdef HEX_LOG
+      IncVal(numCastNoCacheUse, 1);
+      IncVal(numCastSame, 1);
+#endif
+      VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+      VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+      VerifyResultCache[CacheIndex].VerifyResult = SAFECASTSAME;
+      return DstAddr;
+    }
+
+    if (VerifyResultCache[CacheIndex].SrcHValue == SrcTypeHashValue &&
+        VerifyResultCache[CacheIndex].DstHValue == DstTypeHashValue) {
+#ifdef HEX_LOG
+      IncVal(numCastHit, 1);
+#endif
+      if (VerifyResultCache[CacheIndex].VerifyResult != BADCAST) {
+#ifdef HEX_LOG
+        char VerifyResult = VerifyResultCache[CacheIndex].VerifyResult;
+        switch (VerifyResult) {
+        case SAFECASTUPCAST:
+          IncVal(numCastNonBadCast, 1);
+          break;
+        case SAFECASTSAME:
+          IncVal(numCastSame, 1);
+          break;
+        case FAILINFO:
+          IncVal(numMissFindObj, 1);
+          break;
+        }
+#endif
+        return DstAddr;
+      }
+    }
+
+    else {
+#ifdef HEX_LOG
+      IncVal(numCastMiss, 1);
+#endif
+      uptr* RuleAddr = FindValue->RuleAddr;
+      if (RuleAddr) {
+        uint64_t RuleHash;
+        char *BaseAddr = (char *)RuleAddr;
+        uint64_t RuleSize = *(FindValue->RuleAddr);
+        uint64_t start = 1, end = RuleSize, middle;
+        middle = (start + end) / 2;
+
+        while (start <= end) {
+          RuleHash = *((uint64_t *)(BaseAddr + (sizeof(uint64_t) * middle)));
+
+          if (RuleHash < DstTypeHashValue)
+            start = middle + 1;
+          else if(RuleHash == DstTypeHashValue) {
+            VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+            VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+            VerifyResultCache[CacheIndex].VerifyResult = SAFECASTUPCAST;
+#ifdef HEX_LOG
+            IncVal(numCastNonBadCast, 1);
+#endif
+            return DstAddr;
+          }
+          else
+            end = middle - 1;
+          middle = (start + end) /2;
+        }
+      } else {
+        VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+        VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+        VerifyResultCache[CacheIndex].VerifyResult = FAILINFO;
+#ifdef HEX_LOG
+        IncVal(numMissFindObj, 1);
+#endif
+        return nullptr;
+      }
+
+      std::unordered_map<uint64_t, PhantomHashSet*>::iterator it;
+      it = ObjPhantomInfo->find(DstTypeHashValue);
+      if (it != ObjPhantomInfo->end()) {
+        PhantomHashSet *TargetPhantomHashSet = it->second;
+        char *BaseAddr = (char *)RuleAddr;
+        uint64_t RuleSize = *(FindValue->RuleAddr);
+        uint64_t RuleHash;
+        for (uint64_t PhantomHash : *TargetPhantomHashSet) {
+          uint64_t start = 1, end = RuleSize, middle;
+          middle = (start + end) / 2;
+          while (start <= end) {
+            RuleHash = *((uint64_t *)(BaseAddr + (sizeof(uint64_t) * middle)));
+            if (RuleHash < PhantomHash)
+              start = middle + 1;
+            else if(RuleHash == PhantomHash) {
+              VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+              VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+              VerifyResultCache[CacheIndex].VerifyResult = SAFECASTUPCAST;
+#ifdef HEX_LOG
+              IncVal(numCastNonBadCast, 1);
+#endif
+              return DstAddr;
+            }
+            else
+              end = middle - 1;
+            middle = (start + end) /2;
+          }
+        }
+      }
+
+      VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+      VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+      VerifyResultCache[CacheIndex].VerifyResult = BADCAST;
+    }
+
+#if defined(PRINT_BAD_CASTING) || defined(PRINT_BAD_CASTING_FILE)
+      IncVal(numBadCastType3, 1);
+      printTypeConfusion(3, SrcTypeHashValue, DstTypeHashValue);
+#endif
+
+#ifdef HEX_LOG
+    IncVal(numCastBadCast, 1);
+#endif
+    return nullptr;
+  }
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __type_casting_verification_inline(const uint64_t SrcTypeHashValue,
+                                         const uint64_t DstTypeHashValue,
+                                         const uint64_t ObjMapIndex,
+                                         const uint64_t CacheIndex) {
+#ifdef HEX_LOG
+  IncVal(numCasting, 1);
+  IncVal(numVerifiedCasting, 1);
+  IncVal(numLookHit, 1);
+  IncVal(numCastMiss, 1);
+#endif
+
+  if (SrcTypeHashValue == DstTypeHashValue) {
+#ifdef HEX_LOG
+    IncVal(numCastSame, 1);
+#endif
+    VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+    VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+    VerifyResultCache[CacheIndex].VerifyResult = SAFECASTSAME;
+    return;
+  }
+
+  ObjTypeMapEntry *FindValue = &ObjTypeMap[ObjMapIndex];
+  uptr* RuleAddr = FindValue->RuleAddr;
+  if (RuleAddr) {
+    uint64_t RuleHash;
+    char *BaseAddr = (char *)RuleAddr;
+    uint64_t RuleSize = *(FindValue->RuleAddr);
+    uint64_t start = 1, end = RuleSize, middle;
+    middle = (start + end) / 2;
+
+    while (start <= end) {
+      RuleHash = *((uint64_t *)(BaseAddr + (sizeof(uint64_t) * middle)));
+
+      if (RuleHash < DstTypeHashValue)
+        start = middle + 1;
+      else if(RuleHash == DstTypeHashValue) {
+        VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+        VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+        VerifyResultCache[CacheIndex].VerifyResult = SAFECASTUPCAST;
+#ifdef HEX_LOG
+        IncVal(numCastNonBadCast, 1);
+#endif
+        return;
+      }
+      else
+        end = middle - 1;
+      middle = (start + end) /2;
+    }
+  } else {
+    VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+    VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+    VerifyResultCache[CacheIndex].VerifyResult = FAILINFO;
+#ifdef HEX_LOG
+    IncVal(numMissFindObj, 1);
+#endif
+    return;
+  }
+
+  std::unordered_map<uint64_t, PhantomHashSet*>::iterator it;
+  it = ObjPhantomInfo->find(DstTypeHashValue);
+  if (it != ObjPhantomInfo->end()) {
+    PhantomHashSet *TargetPhantomHashSet = it->second;
+    char *BaseAddr = (char *)RuleAddr;
+    uint64_t RuleSize = *(FindValue->RuleAddr);
+    uint64_t RuleHash;
+    for (uint64_t PhantomHash : *TargetPhantomHashSet) {
+      uint64_t start = 1, end = RuleSize, middle;
+      middle = (start + end) / 2;
+      while (start <= end) {
+        RuleHash = *((uint64_t *)(BaseAddr + (sizeof(uint64_t) * middle)));
+        if (RuleHash < PhantomHash)
+          start = middle + 1;
+        else if(RuleHash == PhantomHash) {
+          VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+          VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+          VerifyResultCache[CacheIndex].VerifyResult = SAFECASTUPCAST;
+#ifdef HEX_LOG
+          IncVal(numCastNonBadCast, 1);
+#endif
+          return;
+        }
+        else
+          end = middle - 1;
+        middle = (start + end) /2;
+      }
+    }
+  }
+
+  VerifyResultCache[CacheIndex].SrcHValue = SrcTypeHashValue;
+  VerifyResultCache[CacheIndex].DstHValue = DstTypeHashValue;
+  VerifyResultCache[CacheIndex].VerifyResult = BADCAST;
+#if defined(PRINT_BAD_CASTING) || defined(PRINT_BAD_CASTING_FILE)
+  IncVal(numBadCastType4, 1);
+  printTypeConfusion(4, SrcTypeHashValue, DstTypeHashValue);
+#endif
+#ifdef HEX_LOG
+  IncVal(numCastBadCast, 1);
+#endif
+  return;
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __type_casting_verification_print_cache_result(const uint64_t index) {
+#ifdef PRINT_BAD_CASTING
+  printf("== HexType Type confusion Report\n");
+#endif
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __type_casting_verification_inline_normal(uptr* const SrcAddr,
+                                               const uint64_t DstTypeHashValue) {
+  verifyTypeCasting(SrcAddr, SrcAddr, DstTypeHashValue);
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __type_casting_verification(uptr* const SrcAddr,
+                                       const uint64_t DstTypeHashValue) {
+  verifyTypeCasting(SrcAddr, SrcAddr, DstTypeHashValue);
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __type_casting_verification_changing(uptr* const SrcAddr,
+                                          uptr* const DstAddr,
+                                          const uint64_t DstTypeHashValue) {
+  verifyTypeCasting(SrcAddr, DstAddr, DstTypeHashValue);
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void* __dynamic_casting_verification(uptr* const SrcAddr,
+                                     const uint64_t DstTypeHashValue,
+                                     std::ptrdiff_t Src2dst_offset) {
+  uptr* TmpAddr = (uptr *)((char *)SrcAddr - Src2dst_offset);
+  return verifyTypeCasting(SrcAddr, TmpAddr, DstTypeHashValue);
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __update_direct_oinfo(uptr* const AllocAddr, const uint64_t TypeHashValue,
+                           const int Offset,
+                           uptr* const RuleAddr) {
+  uptr MapIndex = getHash((uptr)AllocAddr);
+  if (ObjTypeMap[MapIndex].ObjAddr == nullptr ||
+      ObjTypeMap[MapIndex].ObjAddr == AllocAddr) {
+    ObjTypeMap[MapIndex].ObjAddr = AllocAddr;
+    ObjTypeMap[MapIndex].TypeHashValue = TypeHashValue;
+    ObjTypeMap[MapIndex].Offset = Offset;
+    ObjTypeMap[MapIndex].HeapArraySize = 1;
+    ObjTypeMap[MapIndex].RuleAddr = RuleAddr;
+    return;
+  }
+#ifdef HEX_LOG
+  IncVal(numUpdateMiss, 1);
+#endif
+  if (ObjTypeMap[MapIndex].HexTree == nullptr)
+    ObjTypeMap[MapIndex].HexTree = rbtree_create();
+
+  ObjTypeMapEntry *ObjValue =
+    (ObjTypeMapEntry*)malloc(sizeof(ObjTypeMapEntry));
+  memcpy(ObjValue, &ObjTypeMap[MapIndex], sizeof(ObjTypeMapEntry));
+
+  rbtree_insert(ObjTypeMap[MapIndex].HexTree,
+                ObjTypeMap[MapIndex].ObjAddr, ObjValue);
+  ObjTypeMap[MapIndex].ObjAddr = AllocAddr;
+  ObjTypeMap[MapIndex].TypeHashValue = TypeHashValue;
+  ObjTypeMap[MapIndex].Offset = Offset;
+  ObjTypeMap[MapIndex].HeapArraySize = 1;
+  ObjTypeMap[MapIndex].RuleAddr = RuleAddr;
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __update_direct_oinfo_inline(uptr* const AllocAddr,
+                                  const uint64_t TypeHashValue,
+                                  const int Offset,
+                                  uptr* RuleAddr,
+                                  const uint64_t MapIndex) {
+#ifdef HEX_LOG
+  IncVal(numUpdateMiss, 1);
+#endif
+  if (ObjTypeMap[MapIndex].HexTree == nullptr)
+    ObjTypeMap[MapIndex].HexTree = rbtree_create();
+
+  ObjTypeMapEntry *ObjValue =
+    (ObjTypeMapEntry*)malloc(sizeof(ObjTypeMapEntry));
+  memcpy(ObjValue, &ObjTypeMap[MapIndex], sizeof(ObjTypeMapEntry));
+
+  rbtree_insert(ObjTypeMap[MapIndex].HexTree,
+                ObjTypeMap[MapIndex].ObjAddr, ObjValue);
+  ObjTypeMap[MapIndex].ObjAddr = AllocAddr;
+  ObjTypeMap[MapIndex].TypeHashValue = TypeHashValue;
+  ObjTypeMap[MapIndex].Offset = Offset;
+  ObjTypeMap[MapIndex].HeapArraySize = 1;
+  ObjTypeMap[MapIndex].RuleAddr = RuleAddr;
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __handle_reinterpret_cast(uptr* const AllocAddr,
+                               const uint64_t TypeHashValue,
+                               const int Offset,
+                               uptr* const RuleAddr) {
+  ObjTypeMapEntry *FindValue = findObjInfo(AllocAddr);
+  if (FindValue) {
+    if (FindValue->Offset != -1)
+      return;
+    //  verifyTypeCasting(AllocAddr, AllocAddr, TypeHashValue);
+  }
+  __update_direct_oinfo(AllocAddr, TypeHashValue, -1, RuleAddr);
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __update_oinfo(uptr* const AllocAddr, const uint64_t TypeHashValue,
+                    const int Offset,
+                    const uint32_t TypeSize, const unsigned long ArraySize,
+                    uptr* const RuleAddr) {
+  for (uint32_t i=0;i<ArraySize;i++) {
+    uptr *addr = (uptr *)((char *)AllocAddr + (TypeSize*i));
+    uptr MapIndex = getHash((uptr)addr);
+
+    if (ObjTypeMap[MapIndex].ObjAddr == nullptr ||
+        ObjTypeMap[MapIndex].ObjAddr == addr) {
+      ObjTypeMap[MapIndex].ObjAddr = addr;
+      ObjTypeMap[MapIndex].TypeHashValue = TypeHashValue;
+      ObjTypeMap[MapIndex].Offset = Offset;
+      ObjTypeMap[MapIndex].HeapArraySize  = ArraySize;
+      ObjTypeMap[MapIndex].RuleAddr = RuleAddr;
+      continue;
+    }
+
+    else {
+#ifdef HEX_LOG
+      IncVal(numUpdateMiss, 1);
+#endif
+      if (ObjTypeMap[MapIndex].HexTree == nullptr)
+        ObjTypeMap[MapIndex].HexTree = rbtree_create();
+
+      ObjTypeMapEntry *ObjValue =
+        (ObjTypeMapEntry*)malloc(sizeof(ObjTypeMapEntry));
+      memcpy(ObjValue, &ObjTypeMap[MapIndex], sizeof(ObjTypeMapEntry));
+
+      rbtree_insert(ObjTypeMap[MapIndex].HexTree,
+                    ObjTypeMap[MapIndex].ObjAddr, ObjValue);
+      ObjTypeMap[MapIndex].ObjAddr = addr;
+      ObjTypeMap[MapIndex].TypeHashValue = TypeHashValue;
+      ObjTypeMap[MapIndex].Offset = Offset;
+      ObjTypeMap[MapIndex].HeapArraySize = ArraySize;
+      ObjTypeMap[MapIndex].RuleAddr = RuleAddr;
+    }
+  }
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __remove_direct_oinfo(uptr* const TargetAddr) {
+  uptr MapIndex = getHash((uptr)TargetAddr);
+
+  if (ObjTypeMap[MapIndex].ObjAddr == TargetAddr) {
+    ObjTypeMap[MapIndex].ObjAddr = nullptr;
+    return;
+  }
+#ifdef HEX_LOG
+  IncVal(numRemoveMiss, 1);
+#endif
+  if (ObjTypeMap[MapIndex].HexTree != nullptr &&
+      ObjTypeMap[MapIndex].HexTree->root != nullptr) {
+    ObjTypeMapEntry* FindValue =
+      (ObjTypeMapEntry *)rbtree_lookup(ObjTypeMap[MapIndex].HexTree, TargetAddr);
+    if (FindValue != nullptr) {
+      free(FindValue);
+      rbtree_delete(ObjTypeMap[MapIndex].HexTree, TargetAddr);
+    }
+  }
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __remove_direct_oinfo_inline(uptr* const TargetAddr,
+                                  const uint64_t MapIndex) {
+  if (ObjTypeMap[MapIndex].HexTree != nullptr &&
+      ObjTypeMap[MapIndex].HexTree->root != nullptr) {
+    ObjTypeMapEntry* FindValue =
+      (ObjTypeMapEntry *)rbtree_lookup(ObjTypeMap[MapIndex].HexTree, TargetAddr);
+    if (FindValue != nullptr) {
+      free(FindValue);
+      rbtree_delete(ObjTypeMap[MapIndex].HexTree, TargetAddr);
+    }
+  }
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __remove_oinfo(uptr* const ObjectAddr, const uint32_t TypeSize,
+                    unsigned long ArraySize, const uint32_t AllocType) {
+  if (AllocType == HEAPALLOC || AllocType == REALLOC) {
+    uptr MapIndex = getHash((uptr)ObjectAddr);
+    if (ObjTypeMap[MapIndex].ObjAddr == ObjectAddr)
+      ArraySize = ObjTypeMap[MapIndex].HeapArraySize;
+    else {
+      if (ObjTypeMap[MapIndex].HexTree != nullptr &&
+          ObjTypeMap[MapIndex].HexTree->root != nullptr) {
+        ObjTypeMapEntry* FindValue =
+          (ObjTypeMapEntry *)rbtree_lookup(ObjTypeMap[MapIndex].HexTree, ObjectAddr);
+        if (FindValue != nullptr)
+          ArraySize = FindValue->HeapArraySize;
+      }
+      else
+        ArraySize = 1;
+    }
+  }
+
+  for (uint32_t i=0;i<ArraySize;i++) {
+    uptr *addr = (uptr *)((char *)ObjectAddr + (TypeSize*i));
+    uptr MapIndex = getHash((uptr)addr);
+#ifdef HEX_LOG
+    switch (AllocType) {
+    case HEAPALLOC:
+    case REALLOC:
+      IncVal(numHeapRm, 1);
+      break;
+    }
+#endif
+    if (ObjTypeMap[MapIndex].ObjAddr == addr)
+      ObjTypeMap[MapIndex].ObjAddr = nullptr;
+    else {
+#ifdef HEX_LOG
+      IncVal(numRemoveMiss, 1);
+#endif
+      if (ObjTypeMap[MapIndex].HexTree != nullptr &&
+          ObjTypeMap[MapIndex].HexTree->root != nullptr) {
+        ObjTypeMapEntry* FindValue =
+          (ObjTypeMapEntry *)rbtree_lookup(ObjTypeMap[MapIndex].HexTree, addr);
+        if (FindValue != nullptr) {
+          free(FindValue);
+          rbtree_delete(ObjTypeMap[MapIndex].HexTree, addr);
+        }
+      }
+    }
+  }
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __update_phantom_info(uint64_t *const PhantomInfo) {
+  if (ObjTypeMap == nullptr) {
+#ifdef HEX_LOG
+    InstallAtExitHandler();
+#endif
+    ObjTypeMap = new ObjTypeMapEntry[NUMMAP];
+  }
+
+  if (VerifyResultCache == nullptr)
+    VerifyResultCache = new VerifyResultEntry[NUMCACHE];
+
+  if (ObjPhantomInfo == nullptr)
+    ObjPhantomInfo = new std::unordered_map<uint64_t, PhantomHashSet*>;
+
+  uint64_t pos = 0;
+  uint64_t TotalNum = PhantomInfo[pos++];
+  for (uint64_t i=0;i<TotalNum;i++) {
+    uint64_t TypeHash = PhantomInfo[pos++];
+    uint64_t PhantomNum = PhantomInfo[pos++];
+    PhantomHashSet* PhantomSet;
+    auto it = ObjPhantomInfo->find(TypeHash);
+    bool isExist = false;
+    if (it == ObjPhantomInfo->end()) {
+      PhantomSet = new PhantomHashSet();
+    } else {
+      isExist = true;
+      PhantomSet = it->second;
+    }
+    for (uint64_t j=0;j<PhantomNum;j++) {
+      uint64_t innerHash = PhantomInfo[pos++];
+      auto it2 = ObjPhantomInfo->find(innerHash);
+      if (it2 != ObjPhantomInfo->end()) {
+        if (it2->second != NULL && it2->second != PhantomSet)
+          PhantomSet->insert(it2->second->begin(), it2->second->end());
+        ObjPhantomInfo->erase(it2);
+        ObjPhantomInfo->insert(make_pair(innerHash, PhantomSet));
+      }
+      PhantomSet->insert(innerHash);
+    }
+    if(!isExist)
+      ObjPhantomInfo->insert(make_pair(TypeHash, PhantomSet));
+  }
+}
+
+#ifdef HEX_LOG
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __lookup_success_count(char VerifyResult) {
+  IncVal(numCasting, 1);
+  IncVal(numVerifiedCasting, 1);
+  IncVal(numLookHit, 1);
+  IncVal(numCastHit, 1);
+
+  switch (VerifyResult) {
+  case BADCAST:
+    IncVal(numCastBadCast, 1);
+    break;
+  case SAFECASTUPCAST:
+    IncVal(numCastNonBadCast, 1);
+    break;
+  case SAFECASTSAME:
+    IncVal(numCastSame, 1);
+    break;
+  case FAILINFO:
+    IncVal(numMissFindObj, 1);
+    break;
+  }
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __obj_update_count(uint32_t objUpdateType, uint64_t vla) {
+  switch (objUpdateType) {
+  case STACKALLOC:
+    IncVal(numStackUp, vla);
+    break;
+  case GLOBALALLOC:
+    IncVal(numGloUp, vla);
+    break;
+  case HEAPALLOC:
+  case REALLOC:
+    IncVal(numHeapUp, vla);
+    break;
+  case PLACEMENTNEW:
+    IncVal(numplacementNew, vla);
+    break;
+  case REINTERPRET:
+    IncVal(numreinterpretCast, vla);
+    break;
+  }
+}
+
+extern "C" SANITIZER_INTERFACE_ATTRIBUTE
+void __obj_remove_count(uint32_t objUpdateType, uint64_t vla) {
+  switch (objUpdateType) {
+  case STACKALLOC:
+    IncVal(numStackRm, vla);
+    break;
+  }
+}
+#endif
diff --git a/lib/hextype/hextype.h b/lib/hextype/hextype.h
new file mode 100644
index 0000000..22f3324
--- /dev/null
+++ b/lib/hextype/hextype.h
@@ -0,0 +1,29 @@
+#include "hextype_report.h"
+#include <unordered_map>
+
+#define NUMMAP 268435460
+#define NUMCACHE 16777220
+
+#define BADCAST 0
+#define FAILINFO 1
+#define SAFECASTSAME 2
+#define SAFECASTUPCAST 3
+#define SAFECAST 4
+
+#define STACKALLOC 1
+#define HEAPALLOC 2
+#define GLOBALALLOC 3
+#define REALLOC 4
+#define PLACEMENTNEW 5
+#define REINTERPRET 6
+
+inline uint32_t getHash(uptr a) {
+  return (((a >> 3) & 0xfffffff));
+}
+
+// Stoarge for phantom class information
+typedef std::set<uint64_t> PhantomHashSet;
+static std::unordered_map<uint64_t, PhantomHashSet*> *ObjPhantomInfo;
+
+__attribute__ ((visibility ("default"))) ObjTypeMapEntry *ObjTypeMap;
+__attribute__ ((visibility ("default"))) VerifyResultEntry *VerifyResultCache;
diff --git a/lib/hextype/hextype_rbtree.cc b/lib/hextype/hextype_rbtree.cc
new file mode 100644
index 0000000..8640637
--- /dev/null
+++ b/lib/hextype/hextype_rbtree.cc
@@ -0,0 +1,383 @@
+#include "hextype_rbtree.h"
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define NDEBUG
+typedef rbtree_node node;
+typedef enum rbtree_node_color color;
+
+static node grandparent(node n);
+static node sibling(node n);
+static node uncle(node n);
+static color node_color(node n);
+
+static node new_node(void* key, void* value, color node_color,
+                     node left, node right);
+static node lookup_node(rbtree t, void* key);
+static void rotate_left(rbtree t, node n);
+static void rotate_right(rbtree t, node n);
+
+static void replace_node(rbtree t, node oldn, node newn);
+static void insert_case1(rbtree t, node n);
+static void insert_case2(rbtree t, node n);
+static void insert_case3(rbtree t, node n);
+static void insert_case4(rbtree t, node n);
+static void insert_case5(rbtree t, node n);
+static node maximum_node(node root);
+static void delete_case1(rbtree t, node n);
+static void delete_case2(rbtree t, node n);
+static void delete_case3(rbtree t, node n);
+static void delete_case4(rbtree t, node n);
+static void delete_case5(rbtree t, node n);
+static void delete_case6(rbtree t, node n);
+
+void write_log(char *result, char *filename) {
+  if (getenv("HEXTYPE_LOG_PATH") != nullptr) {
+    char *home = getenv("HEXTYPE_LOG_PATH");
+    char path[MAXPATH];
+    strcpy(path, home);
+    strcat(path, filename);
+
+    FILE *op = fopen(path, "a");
+    if(op != NULL) {
+      fprintf(op, "%s\n", result);
+      fflush(op);
+      fclose(op);
+    }
+  }
+}
+
+node grandparent(node n) {
+  assert (n != NULL);
+  assert (n->parent != NULL); /* Not the root node */
+  assert (n->parent->parent != NULL); /* Not child of root */
+  return n->parent->parent;
+}
+
+node sibling(node n) {
+  assert (n != NULL);
+  assert (n->parent != NULL); /* Root node has no sibling */
+  if (n == n->parent->left)
+    return n->parent->right;
+  else
+    return n->parent->left;
+}
+
+node uncle(node n) {
+  assert (n != NULL);
+  assert (n->parent != NULL); /* Root node has no uncle */
+  assert (n->parent->parent != NULL); /* Children of root have no uncle */
+  return sibling(n->parent);
+}
+
+color node_color(node n) {
+  return n == NULL ? BLACK : n->color;
+}
+
+rbtree rbtree_create() {
+  rbtree t = (rbtree)malloc(sizeof(struct rbtree_t));
+  t->root = NULL;
+  return t;
+}
+
+node new_node(void* key, void* value, color node_color, node left, node right) {
+  node result = (node)malloc(sizeof(struct rbtree_node_t));
+
+  if(result == NULL) {
+    return NULL;
+  }
+
+  else {
+    result->key = key;
+    result->value = value;
+    result->color = node_color;
+    result->left = left;
+    result->right = right;
+    if (left  != NULL)  left->parent = result;
+    if (right != NULL) right->parent = result;
+    result->parent = NULL;
+    return result;
+  }
+}
+
+static int compare(void* left, void* right);
+
+int compare(void* leftp, void* rightp) {
+
+  int left = (int)(size_t)leftp;
+  int right = (int)(size_t)rightp;
+  if (left < right)
+    return -1;
+  else if (left > right)
+    return 1;
+  else {
+    assert (left == right);
+    return 0;
+  }
+}
+
+node lookup_node(rbtree t, void* key) {
+
+  node n = t->root;
+  while (n != NULL) {
+    int comp_result = compare(key, n->key);
+    if (comp_result == 0) {
+      return n;
+    } else if (comp_result < 0) {
+      n = n->left;
+    } else {
+      assert(comp_result > 0);
+      n = n->right;
+    }
+  }
+  return n;
+}
+
+void* rbtree_lookup(rbtree t, void* key) {
+
+  node n = lookup_node(t, key);
+
+  return n == NULL ? NULL : n->value;
+}
+
+void rotate_left(rbtree t, node n) {
+  node r = n->right;
+  replace_node(t, n, r);
+  n->right = r->left;
+  if (r->left != NULL) {
+    r->left->parent = n;
+  }
+  r->left = n;
+  n->parent = r;
+}
+
+void rotate_right(rbtree t, node n) {
+  node L = n->left;
+  replace_node(t, n, L);
+  n->left = L->right;
+  if (L->right != NULL) {
+    L->right->parent = n;
+  }
+  L->right = n;
+  n->parent = L;
+}
+
+void replace_node(rbtree t, node oldn, node newn) {
+  if (oldn->parent == NULL) {
+    t->root = newn;
+  } else {
+    if (oldn == oldn->parent->left)
+      oldn->parent->left = newn;
+    else
+      oldn->parent->right = newn;
+  }
+  if (newn != NULL) {
+    newn->parent = oldn->parent;
+  }
+}
+
+void rbtree_insert(rbtree t, void* key, void* value) {
+
+  node inserted_node = new_node(key, value, RED, NULL, NULL);
+
+  if(inserted_node == NULL) {
+    return;
+  }
+
+  if (t->root == NULL) {
+    t->root = inserted_node;
+  } else {
+    node n = t->root;
+    while (1) {
+      int comp_result = compare(key, n->key);
+      if (comp_result == 0) {
+        n->value = value;
+        return;
+      } else if (comp_result < 0) {
+        if (n->left == NULL) {
+          n->left = inserted_node;
+          break;
+        } else {
+          n = n->left;
+        }
+      } else {
+        assert (comp_result > 0);
+        if (n->right == NULL) {
+          n->right = inserted_node;
+          break;
+        } else {
+          n = n->right;
+        }
+      }
+    }
+    inserted_node->parent = n;
+  }
+  insert_case1(t, inserted_node);
+}
+
+void insert_case1(rbtree t, node n) {
+  if (n->parent == NULL)
+    n->color = BLACK;
+  else
+    insert_case2(t, n);
+}
+
+void insert_case2(rbtree t, node n) {
+  if (node_color(n->parent) == BLACK)
+    return; /* Tree is still valid */
+  else
+    insert_case3(t, n);
+}
+
+void insert_case3(rbtree t, node n) {
+  if (node_color(uncle(n)) == RED) {
+    n->parent->color = BLACK;
+    uncle(n)->color = BLACK;
+    grandparent(n)->color = RED;
+    insert_case1(t, grandparent(n));
+  } else {
+    insert_case4(t, n);
+  }
+}
+
+void insert_case4(rbtree t, node n) {
+  if (n == n->parent->right && n->parent == grandparent(n)->left) {
+    rotate_left(t, n->parent);
+    n = n->left;
+  } else if (n == n->parent->left && n->parent == grandparent(n)->right) {
+    rotate_right(t, n->parent);
+    n = n->right;
+  }
+  insert_case5(t, n);
+}
+
+void insert_case5(rbtree t, node n) {
+  n->parent->color = BLACK;
+  grandparent(n)->color = RED;
+  if (n == n->parent->left && n->parent == grandparent(n)->left) {
+    rotate_right(t, grandparent(n));
+  } else {
+    assert (n == n->parent->right && n->parent == grandparent(n)->right);
+    rotate_left(t, grandparent(n));
+  }
+}
+
+int rbtree_delete(rbtree t, void* key) {
+  node child;
+
+  node n = lookup_node(t, key);
+  if (n == NULL) return 0;  /* Key not found, do nothing */
+  if (n->left != NULL && n->right != NULL) {
+    /* Copy key/value from predecessor and then delete it instead */
+    node pred = maximum_node(n->left);
+    n->key   = pred->key;
+    n->value = pred->value;
+    n = pred;
+  }
+
+  assert(n->left == NULL || n->right == NULL);
+  child = n->right == NULL ? n->left  : n->right;
+  if (node_color(n) == BLACK) {
+    n->color = node_color(child);
+    delete_case1(t, n);
+  }
+  replace_node(t, n, child);
+  if (n->parent == NULL && child != NULL) // root should be black
+    child->color = BLACK;
+
+  free(n);
+
+  return 1;
+}
+
+static node maximum_node(node n) {
+  assert (n != NULL);
+  while (n->right != NULL) {
+    n = n->right;
+  }
+  return n;
+}
+
+void delete_case1(rbtree t, node n) {
+  if (n->parent == NULL)
+    return;
+  else
+    delete_case2(t, n);
+}
+
+void delete_case2(rbtree t, node n) {
+  if (node_color(sibling(n)) == RED) {
+    n->parent->color = RED;
+    sibling(n)->color = BLACK;
+    if (n == n->parent->left)
+      rotate_left(t, n->parent);
+    else
+      rotate_right(t, n->parent);
+  }
+  delete_case3(t, n);
+}
+
+void delete_case3(rbtree t, node n) {
+  if (node_color(n->parent) == BLACK &&
+      node_color(sibling(n)) == BLACK &&
+      node_color(sibling(n)->left) == BLACK &&
+      node_color(sibling(n)->right) == BLACK)
+  {
+    sibling(n)->color = RED;
+    delete_case1(t, n->parent);
+  }
+  else
+    delete_case4(t, n);
+}
+
+void delete_case4(rbtree t, node n) {
+  if (node_color(n->parent) == RED &&
+      node_color(sibling(n)) == BLACK &&
+      node_color(sibling(n)->left) == BLACK &&
+      node_color(sibling(n)->right) == BLACK)
+  {
+    sibling(n)->color = RED;
+    n->parent->color = BLACK;
+  }
+  else
+    delete_case5(t, n);
+}
+
+void delete_case5(rbtree t, node n) {
+  if (n == n->parent->left &&
+      node_color(sibling(n)) == BLACK &&
+      node_color(sibling(n)->left) == RED &&
+      node_color(sibling(n)->right) == BLACK)
+  {
+    sibling(n)->color = RED;
+    sibling(n)->left->color = BLACK;
+    rotate_right(t, sibling(n));
+  }
+  else if (n == n->parent->right &&
+           node_color(sibling(n)) == BLACK &&
+           node_color(sibling(n)->right) == RED &&
+           node_color(sibling(n)->left) == BLACK)
+  {
+    sibling(n)->color = RED;
+    sibling(n)->right->color = BLACK;
+    rotate_left(t, sibling(n));
+  }
+  delete_case6(t, n);
+}
+
+void delete_case6(rbtree t, node n) {
+  sibling(n)->color = node_color(n->parent);
+  n->parent->color = BLACK;
+  if (n == n->parent->left) {
+    assert (node_color(sibling(n)->right) == RED);
+    sibling(n)->right->color = BLACK;
+    rotate_left(t, n->parent);
+  }
+  else
+  {
+    assert (node_color(sibling(n)->left) == RED);
+    sibling(n)->left->color = BLACK;
+    rotate_right(t, n->parent);
+  }
+}
diff --git a/lib/hextype/hextype_rbtree.h b/lib/hextype/hextype_rbtree.h
new file mode 100644
index 0000000..9678dde
--- /dev/null
+++ b/lib/hextype/hextype_rbtree.h
@@ -0,0 +1,45 @@
+#include "sanitizer_common/sanitizer_stacktrace.h"
+#include <map>
+#include <set>
+
+#define MAXPATH 1000
+
+#define HEX_LOG
+#define PRINT_BAD_CASTING
+#define PRINT_BAD_CASTING_FILE
+
+enum rbtree_node_color { RED, BLACK };
+
+typedef struct rbtree_node_t {
+  void* key;
+  void* value;
+  struct rbtree_node_t* left;
+  struct rbtree_node_t* right;
+  struct rbtree_node_t* parent;
+  enum rbtree_node_color color;
+} *rbtree_node;
+
+typedef struct rbtree_t {
+  rbtree_node root;
+} *rbtree;
+
+typedef struct ObjTypeMapEntry {
+  uptr* ObjAddr;
+  uptr* RuleAddr;
+  uint64_t TypeHashValue;
+  uint32_t HeapArraySize;
+  int Offset;
+  rbtree HexTree;
+} ObjTypeMapEntry;
+
+typedef struct VerifyResultEntry {
+  uint64_t SrcHValue;
+  uint64_t DstHValue;
+  char VerifyResult;
+} VerifyResultEntry;
+
+rbtree rbtree_create();
+void* rbtree_lookup(rbtree t, void* key);
+void rbtree_insert(rbtree t, void* key, void* value);
+int rbtree_delete(rbtree t, void* key);
+void write_log(char *result, char *filename);
diff --git a/lib/hextype/hextype_report.cc b/lib/hextype/hextype_report.cc
new file mode 100644
index 0000000..acc08f1
--- /dev/null
+++ b/lib/hextype/hextype_report.cc
@@ -0,0 +1,226 @@
+#include "hextype_report.h"
+#include <inttypes.h>
+#include <execinfo.h>
+#include <unistd.h>
+
+#ifdef HEX_LOG
+#define BT_BUF_SIZE 100
+
+std::atomic<unsigned long> count_index[MAXINDEX];
+
+void IncVal(int index, int count) {
+  count_index[index].fetch_add(count);
+}
+
+unsigned long getVal(int index) {
+  return count_index[index].load();
+}
+
+void printInfotoFile(char *PrintStr, char *FileName) {
+  write_log(PrintStr, FileName);
+}
+
+void printTypeConfusion(int ErrorType, uint64_t SrcHash, uint64_t DstHash) {
+  int j, nptrs;
+  void *buffer[BT_BUF_SIZE];
+  char **strings;
+
+#ifdef PRINT_BAD_CASTING
+  printf("== HexType Type Confusion Report ==\n");
+  printf("%d %" PRIu64 " %" PRIu64 "\n", ErrorType, SrcHash, DstHash);
+
+  nptrs = backtrace(buffer, BT_BUF_SIZE);
+  strings = backtrace_symbols(buffer, nptrs);
+  if (strings != NULL)
+    for (j = 0; j < nptrs; j++)
+      printf("%s\n", strings[j]);
+  free(strings);
+#endif
+#ifdef PRINT_BAD_CASTING_FILE
+  char tmp[MAXLEN];
+  char fileName[MAXLEN] = "/typeconfusion.txt";
+
+  snprintf(tmp, sizeof(tmp), "\n== HexType Type Confusion Report ==");
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%d %" PRIu64 " %" PRIu64 "",
+           ErrorType, SrcHash, DstHash);
+  printInfotoFile(tmp, fileName);
+
+  nptrs = backtrace(buffer, BT_BUF_SIZE);
+  strings = backtrace_symbols(buffer, nptrs);
+  if (strings != NULL)
+    for (j = 0; j < nptrs; j++) {
+      snprintf(tmp, sizeof(tmp), "%s", strings[j]);
+      printInfotoFile(tmp, fileName);
+    }
+  free(strings);
+#endif
+}
+
+static void PrintStatResult(void) {
+  char tmp[MAXLEN];
+  char fileName[MAXLEN] = "/total_result.txt";
+
+  snprintf(tmp, sizeof(tmp), "== Object Update status ==\n");
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu: Object update\n", getVal(numGloUp) +
+          getVal(numHeapUp) + getVal(numStackUp));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Object update hit\n", getVal(numGloUp) +
+          getVal(numHeapUp) + getVal(numStackUp) - getVal(numUpdateMiss));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Object update miss\n",
+           getVal(numUpdateMiss));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Global Object Update\n",
+          getVal(numGloUp));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Heap Object Update\n", getVal(numHeapUp));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Stack Object Update\n",
+          getVal(numStackUp));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu: Object remove\n", getVal(numHeapRm) +
+          getVal(numStackRm));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Object remove hit\n", getVal(numHeapRm) +
+          getVal(numStackRm) - getVal(numRemoveMiss));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Object remove miss\n",
+           getVal(numRemoveMiss));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Heap object Remove\n", getVal(numHeapRm));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Stack object Remove\n",getVal(numStackRm));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "== Casting verification status ==\n");
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu (verified %lu): Casting operation\n",
+           getVal(numCasting), getVal(numVerifiedCasting));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu: Object lookup success\n",
+           getVal(numLookHit));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp),
+           "\t%lu: Object lookup success (find in the RB-tree)\n",
+          getVal(numLookMiss));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp),
+           "\t%lu: Object lookup fail (fail to find object)\n",
+           getVal(numLookFail));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu %lu: Verified type casting\n",
+          getVal(numVerifiedCasting),
+          getVal(numCastNonBadCast) +
+          getVal(numCastSame) +
+          getVal(numCastBadCast)+getVal(numMissFindObj));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp),
+           "\t\t%lu: Safe casting (src and dst are same type)\n",
+           getVal(numCastSame));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t\t%lu: Safe casting (up casting)\n",
+          getVal(numCastNonBadCast));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp),
+           "\t\t%lu: Type confusion cases\n",getVal(numCastBadCast));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp),
+           "\t\t%lu: Type confusion type %lu %lu %lu %lu\n",
+           getVal(numBadCastType1),
+           getVal(numBadCastType2),
+           getVal(numBadCastType3),
+           getVal(numBadCastType4));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t\t\t%lu: Type confusion cases(minus offset)\n",
+          getVal(numCastBadCastMinus));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp),
+           "\t\t%lu: No type relation info\n",getVal(numMissFindObj));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t%lu :Casting cache use status\n",
+           getVal(numCastHit) + getVal(numCastMiss) +
+           getVal(numCastNoCacheUse));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t\t%lu: Casting operation cache hit\n",
+          getVal(numCastHit));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t\t%lu: Casting operation cache Miss\n",
+          getVal(numCastMiss));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "\t\t%lu: Casting operation no cache use\n",
+          getVal(numCastNoCacheUse));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "== Count dynamic and static cast number ==\n");
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu: Check dynamic_cast number\n",
+          getVal(numdynamicCast));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu: Check static_cast number\n",
+           getVal(numstaticCast));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu: Check reinterpret_cast number\n",
+          getVal(numreinterpretCast));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu: reinterpret_cast objects\n",
+          getVal(numreinterpretCast));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "%lu: placement new objects\n",
+          getVal(numplacementNew));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "== Summary == \n");
+  snprintf(tmp, sizeof(tmp), "Objects: %lu %lu %lu\n",
+           getVal(numGloUp) + getVal(numHeapUp) + getVal(numStackUp),
+           getVal(numHeapRm) + getVal(numStackRm),
+          getVal(numGloUp) + getVal(numHeapUp) + getVal(numStackUp) +
+          getVal(numreinterpretCast) + getVal(numplacementNew));
+  printInfotoFile(tmp, fileName);
+
+  snprintf(tmp, sizeof(tmp), "Casting: %lu %lu %lu\n",
+           getVal(numCasting), getVal(numVerifiedCasting), getVal(numCastBadCast));
+  printInfotoFile(tmp, fileName);
+}
+
+static void HexTypeAtExit(void) {
+  PrintStatResult();
+}
+
+void InstallAtExitHandler() {
+  atexit(HexTypeAtExit);
+}
+#endif
diff --git a/lib/hextype/hextype_report.h b/lib/hextype/hextype_report.h
new file mode 100644
index 0000000..89c32ce
--- /dev/null
+++ b/lib/hextype/hextype_report.h
@@ -0,0 +1,59 @@
+#include "hextype_rbtree.h"
+
+#ifdef HEX_LOG
+#include <atomic>
+
+#define MAXINDEX 1000
+#define MAXLEN 1000
+
+#define numUpdate 1
+#define numUpdateHit 2
+#define numUpdateMiss 3
+
+#define numGloUp 4
+#define numStackUp 5
+#define numStackRm 6
+#define numHeapUp 7
+#define numHeapRm 8
+
+#define numRemoveHit 9
+#define numRemoveMiss 10
+
+#define numCasting 11
+#define numVerifiedCasting 12
+#define numCastingNull 13
+#define numHashMapNull 14
+
+#define numLookHit 15
+#define numLookMiss 16
+#define numLookFail 17
+
+#define numCastSame 18
+#define numCastHit 19
+#define numCastMiss 20
+#define numCastNoCacheUse 21
+
+#define numCastBadCast 22
+#define numCastNonBadCast 23
+#define numMissFindObj 24
+#define numCastBadCastMinus 25
+
+#define numrealloc 26
+
+#define numdynamicCast 27
+#define numstaticCast 28
+#define numreinterpretCast 29
+#define numplacementNew 30
+
+#define numRulesNull 31
+
+#define numBadCastType1 32
+#define numBadCastType2 33
+#define numBadCastType3 34
+#define numBadCastType4 35
+
+void IncVal(int index, int count);
+unsigned long getVal(int index);
+void printTypeConfusion(int, uint64_t, uint64_t);
+void InstallAtExitHandler();
+#endif
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index f986ec1..182671b 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -70,6 +70,9 @@ if(COMPILER_RT_CAN_EXECUTE_TESTS)
   if(COMPILER_RT_HAS_SAFESTACK)
     add_subdirectory(safestack)
   endif()
+  if(COMPILER_RT_HAS_HEXTYPE)
+    add_subdirectory(hextype)
+  endif()
 endif()
 
 if(COMPILER_RT_STANDALONE_BUILD)
diff --git a/test/hextype/CMakeLists.txt b/test/hextype/CMakeLists.txt
new file mode 100644
index 0000000..5e8dde2
--- /dev/null
+++ b/test/hextype/CMakeLists.txt
@@ -0,0 +1,17 @@
+set(HEXTYPE_LIT_TESTS_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+
+set(HEXTYPE_LIT_TEST_MODE "Standalone")
+configure_lit_site_cfg(
+  ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in
+  ${CMAKE_CURRENT_BINARY_DIR}/HEXTYPEConfig/lit.site.cfg)
+set(HEXTYPE_TESTSUITES ${CMAKE_CURRENT_BINARY_DIR}/HEXTYPEConfig)
+
+set(HEXTYPE_TEST_DEPS ${SANITIZER_COMMON_LIT_TEST_DEPS})
+if(NOT COMPILER_RT_STANDALONE_BUILD)
+  list(APPEND HEXTYPE_TEST_DEPS hextype)
+endif()
+
+add_lit_testsuite(check-runtime-hextype "Running HEXTYPE tests"
+  ${HEXTYPE_TESTSUITES}
+  DEPENDS ${HEXTYPE_TEST_DEPS})
+set_target_properties(check-runtime-hextype PROPERTIES FOLDER "HEXTYPE unittests")
diff --git a/test/hextype/TestCases/simple_bad_cast.cc b/test/hextype/TestCases/simple_bad_cast.cc
new file mode 100644
index 0000000..abe5f11
--- /dev/null
+++ b/test/hextype/TestCases/simple_bad_cast.cc
@@ -0,0 +1,43 @@
+// RUN: %clangxx -fsanitize=hextype %s -O3 -o %t
+// RUN: %run %t 2>&1 | FileCheck %s --strict-whitespace
+
+#include <stdio.h>
+
+namespace foo {
+    class GrandParent {
+    public:
+        unsigned int age;
+    };
+
+    class Parent : public GrandParent {
+    public:
+        virtual void foo();
+        char name[10];
+    };
+    void Parent::foo() {
+    }
+
+    class Child_1 : public Parent {
+    public:
+        virtual void foo();
+    };
+    void Child_1::foo() {
+    }
+
+    class Child_2 : public Parent {
+    public:
+        Child_1 c1;
+        virtual void foo();
+    };
+    void Child_2::foo() {
+    }
+}
+
+using namespace foo;
+
+int main() {
+    GrandParent *p = new GrandParent();
+    // CHECK:== HexType Type Confusion Report ==
+    Parent *g = static_cast<Parent*>(p);
+    return 0;
+}
diff --git a/test/hextype/lit.common.cfg b/test/hextype/lit.common.cfg
new file mode 100644
index 0000000..ba4531e
--- /dev/null
+++ b/test/hextype/lit.common.cfg
@@ -0,0 +1,43 @@
+# -*- Python -*-
+
+import os
+
+def get_required_attr(config, attr_name):
+  attr_value = getattr(config, attr_name, None)
+  if attr_value == None:
+    lit_config.fatal(
+      "No attribute %r in test configuration! You may need to run "
+      "tests from your build directory or add this attribute "
+      "to lit.site.cfg " % attr_name)
+  return attr_value
+
+# Setup source root.
+config.test_source_root = os.path.dirname(__file__)
+
+hextype_lit_test_mode = get_required_attr(config, 'hextype_lit_test_mode')
+if hextype_lit_test_mode == "Standalone":
+  config.name = 'CastVerifier'
+  clang_hextype_cflags = []
+else:
+  lit_config.fatal("Unknown HEXTYPE test mode: %r" % hextype_lit_test_mode)
+
+def build_invocation(compile_flags):
+  return " " + " ".join([config.clang] + compile_flags) + " "
+
+target_cflags = [get_required_attr(config, "target_cflags")]
+clang_hextype_cflags += target_cflags
+clang_hextype_cxxflags = config.cxx_mode_flags + clang_hextype_cflags
+
+# Define %clang and %clangxx substitutions to use in test RUN lines.
+config.substitutions.append( ("%clang ", build_invocation(clang_hextype_cflags)) )
+config.substitutions.append( ("%clangxx ", build_invocation(clang_hextype_cxxflags)) )
+
+# Default test suffixes.
+config.suffixes = ['.c', '.cc', '.cpp']
+
+# UndefinedBehaviorSanitizer tests are currently supported on
+# Linux and Darwin only.
+if config.host_os not in ['Linux', 'Darwin']:
+  config.unsupported = True
+
+config.pipefail = False
diff --git a/test/hextype/lit.site.cfg.in b/test/hextype/lit.site.cfg.in
new file mode 100644
index 0000000..ec3533f
--- /dev/null
+++ b/test/hextype/lit.site.cfg.in
@@ -0,0 +1,8 @@
+# Load common config for all compiler-rt lit tests.
+lit_config.load_config(config, "@COMPILER_RT_BINARY_DIR@/test/lit.common.configured")
+
+# Tool-specific config options.
+config.hextype_lit_test_mode = "@HEXTYPE_LIT_TEST_MODE@"
+
+# Load tool-specific config that would do the real work.
+lit_config.load_config(config, "@HEXTYPE_LIT_TESTS_DIR@/lit.common.cfg")
